"""Functions related to discovery of Adobe files/packages"""
import re

from os import walk
from pathlib import Path
from typing import Any, Dict, List, Optional, Union


def is_installer(f: Path, file_ext: str = ".pkg", install_prefix: str = "_Install") -> bool:
    """Determines if the specified package is an installer
    :param f (Path): file path
    :param file_ext (str): file extension test
    :param install_prefix (str): install package test"""
    return install_prefix in str(f) and file_ext in str(f)


def resolve_product_name(f: Path, file_ext: str = ".pkg", install_prefix: str = "_Install",
                         uninstall_prefix: str = "_Uninstall") -> str:
    """Resolves the product name for the specified file path
    :param f (Path): file path
    :param file_ext (str): file extension
    :param install_prefix (str): the string indicating the install package as named by
                                 default when generated by Adobe
    :param uninstall_prefix (str): the string indicating the uninstall package as named
                                   by default when generated by Adobe"""
    reg_pattern = re.compile(rf"{install_prefix}|{uninstall_prefix}")
    result = str(Path(re.sub(reg_pattern, "", str(f))).name)

    return result


def walk_path(d: Path, file_ext: Optional[Union[str, None]] = ".pkg") -> List:
    """Walk subdirectories in a specified path for the specified file extension
    :param d (Path): directory to traverse searching for specific file extensions
    :param file_ext (str): the file extension to filter on"""
    result = list()
    found_files = set()
    folder_file_exts = [".pkg", ".dmg"]  # These we treat a little differently
    d = d.expanduser()

    if d.exists():
        for path_root, dirs, files in walk(d):
            if file_ext in folder_file_exts:
                for _ in dirs:
                    pkg = Path(path_root).joinpath(_)

                    if file_ext == ".dmg":
                        dmg_glob = [f for f in pkg.glob("*.dmg")]
                        dmg_file = "".join([str(f) for f in dmg_glob if re.search(r"APRO\d+", str(f))])
                        pkg = pkg.joinpath(dmg_file)

                    if pkg.suffix == file_ext:
                        found_files.add(pkg)
            else:
                for f in files:
                    fn = Path(path_root).joinpath(f)
                    found_files.add(fn)

    result = sorted([f for f in found_files])

    return result


def adobe_packages(d: Path) -> Dict[Any, Any]:
    """Discover Adobe installers and uninstallers in a specified path
    :param d (Path): the directory containing Adobe packages to import"""
    result: Dict[Any, Any] = dict()
    packages = walk_path(d)

    for pkg in packages:
        product_name = resolve_product_name(f=Path(pkg))
        product_dict = dict()

        if is_installer(f=pkg):
            acrobat_setup_dir = pkg.joinpath("Contents/Resources/Setup")
            product_dict["installer"] = pkg
            try:
                product_dict["dmg_file"] = list(walk_path(acrobat_setup_dir, file_ext=".dmg"))[0]
            except IndexError:
                pass  # Yeah, do _nothing_, this is how I want this to be handled.
        else:
            product_dict["uninstaller"] = pkg

        try:
            result[product_name].update(product_dict)
        except KeyError:
            result[product_name] = dict()
            result[product_name].update(product_dict)

    return result
